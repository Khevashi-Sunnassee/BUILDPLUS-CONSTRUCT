Below is a full Replit-ready spec + copy/paste code for a Teams-style chat (chat only) using your stack:

Drizzle ORM + PostgreSQL (Neon)

Schema in shared/schema.ts

DB deploy via npm run db:push

Realtime via Socket.IO

Files stored on the Replit server filesystem (/uploads/chat)

@mentions with user dropdown

Dashboard unread + mention badges

Popup chat (only if the user has it enabled)

I‚Äôm writing this as if you have a typical Replit full-stack Node app with a server folder and a shared schema. If your file names differ, only adjust the imports/paths.

0) Folder structure to create

Add these files/folders:

shared/schema.ts              (update: add chat tables)
server/chat/index.ts          (NEW: mounts REST routes + socket)
server/chat/chat.routes.ts    (NEW: REST endpoints)
server/chat/chat.socket.ts    (NEW: socket handlers)
server/chat/chat.files.ts     (NEW: multer upload config)
server/chat/chat.utils.ts     (NEW: helpers)
uploads/chat/                (NEW folder)
src/chat/socket.ts            (NEW: socket client)
src/chat/ChatPanel.tsx        (NEW: chat UI)
src/chat/MentionDropdown.tsx  (NEW: @ mention UI)
src/dashboard/ChatWidget.tsx  (NEW: dashboard widget)

1) Update Drizzle schema (shared/schema.ts)
1.1 Chat tables (copy/paste)

Add these to shared/schema.ts (adapt your users import if you already export it elsewhere).

import {
  pgTable, text, timestamp, integer, index, uniqueIndex, pgEnum
} from "drizzle-orm/pg-core";

// IMPORTANT: use your existing users table export if you already have it.
// Replace this with: import { users } from "./schema";
export const users = pgTable("users", {
  id: text("id").primaryKey(),
  email: text("email").notNull(),
  name: text("name"),
  avatarUrl: text("avatar_url"),
});

// ---- Enums ----
export const conversationTypeEnum = pgEnum("conversation_type", ["DM", "GROUP", "CHANNEL"]);
export const memberRoleEnum = pgEnum("member_role", ["OWNER", "ADMIN", "MEMBER"]);
export const messageFormatEnum = pgEnum("message_format", ["PLAIN", "MARKDOWN"]);
export const notificationTypeEnum = pgEnum("notification_type", ["MESSAGE", "MENTION"]);

// ---- Chat user settings (popup preference) ----
export const userChatSettings = pgTable(
  "user_chat_settings",
  {
    userId: text("user_id")
      .primaryKey()
      .references(() => users.id, { onDelete: "cascade" }),
    popupEnabled: integer("popup_enabled").default(1).notNull(), // 1=true, 0=false
    updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    idxPopup: index("user_chat_settings_popup_idx").on(t.popupEnabled),
  })
);

// ---- Conversations ----
export const conversations = pgTable(
  "conversations",
  {
    id: text("id").primaryKey(),
    type: conversationTypeEnum("type").notNull(),
    name: text("name"),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    idxType: index("conversations_type_idx").on(t.type),
  })
);

// ---- Members ----
export const conversationMembers = pgTable(
  "conversation_members",
  {
    id: text("id").primaryKey(),
    conversationId: text("conversation_id")
      .notNull()
      .references(() => conversations.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    role: memberRoleEnum("role").default("MEMBER").notNull(),
    joinedAt: timestamp("joined_at", { withTimezone: true }).defaultNow().notNull(),
    lastReadAt: timestamp("last_read_at", { withTimezone: true }),
    lastReadMsgId: text("last_read_msg_id"),
  },
  (t) => ({
    uniqMember: uniqueIndex("conv_member_unique").on(t.conversationId, t.userId),
    idxUser: index("conv_member_user_idx").on(t.userId),
    idxConv: index("conv_member_conv_idx").on(t.conversationId),
  })
);

// ---- Messages ----
export const messages = pgTable(
  "messages",
  {
    id: text("id").primaryKey(),
    conversationId: text("conversation_id")
      .notNull()
      .references(() => conversations.id, { onDelete: "cascade" }),
    senderId: text("sender_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    body: text("body"),
    bodyFormat: messageFormatEnum("body_format").default("PLAIN").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
    editedAt: timestamp("edited_at", { withTimezone: true }),
    deletedAt: timestamp("deleted_at", { withTimezone: true }),
    replyToId: text("reply_to_id"),
  },
  (t) => ({
    idxConvCreated: index("messages_conv_created_idx").on(t.conversationId, t.createdAt),
  })
);

// ---- Attachments (stored on Replit server filesystem) ----
export const messageAttachments = pgTable(
  "message_attachments",
  {
    id: text("id").primaryKey(),
    messageId: text("message_id")
      .notNull()
      .references(() => messages.id, { onDelete: "cascade" }),
    fileName: text("file_name").notNull(),
    mimeType: text("mime_type").notNull(),
    sizeBytes: integer("size_bytes").notNull(),
    storageKey: text("storage_key").notNull(), // relative path key
    url: text("url").notNull(),               // served URL
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    idxMsg: index("attachments_message_idx").on(t.messageId),
  })
);

// ---- Reactions ----
export const messageReactions = pgTable(
  "message_reactions",
  {
    id: text("id").primaryKey(),
    messageId: text("message_id")
      .notNull()
      .references(() => messages.id, { onDelete: "cascade" }),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    emoji: text("emoji").notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    uniqReaction: uniqueIndex("reaction_unique").on(t.messageId, t.userId, t.emoji),
    idxMessage: index("reactions_message_idx").on(t.messageId),
  })
);

// ---- Mentions ----
export const messageMentions = pgTable(
  "message_mentions",
  {
    id: text("id").primaryKey(),
    messageId: text("message_id")
      .notNull()
      .references(() => messages.id, { onDelete: "cascade" }),
    mentionedUserId: text("mentioned_user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  },
  (t) => ({
    uniqMention: uniqueIndex("mention_unique").on(t.messageId, t.mentionedUserId),
    idxUser: index("mention_user_idx").on(t.mentionedUserId),
  })
);

// ---- Notifications (dashboard + popup trigger) ----
export const notifications = pgTable(
  "notifications",
  {
    id: text("id").primaryKey(),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    type: notificationTypeEnum("type").notNull(),
    title: text("title").notNull(),
    body: text("body"),
    entityId: text("entity_id"), // conversationId
    messageId: text("message_id"),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
    readAt: timestamp("read_at", { withTimezone: true }),
  },
  (t) => ({
    idxUserCreated: index("notif_user_created_idx").on(t.userId, t.createdAt),
  })
);

1.2 Push schema
npm run db:push

2) Server-side chat module (REST + Socket.IO)
2.1 Install deps
npm i socket.io cors jsonwebtoken multer zod @paralleldrive/cuid2

2.2 Chat helpers: server/chat/chat.utils.ts
import jwt from "jsonwebtoken";

export function getTokenFromReq(req: any) {
  const h = req.headers?.authorization || "";
  if (h.startsWith("Bearer ")) return h.slice(7);
  return null;
}

export function getTokenFromSocket(socket: any) {
  return socket.handshake.auth?.token || getTokenFromReq(socket.request);
}

export function verifyToken(token: string) {
  const secret = process.env.JWT_SECRET || "dev_secret";
  return jwt.verify(token, secret) as any;
}

export function userIdFromDecoded(decoded: any) {
  return decoded.sub || decoded.userId || decoded.id;
}

// Mention token format: @[Name](user:USERID)
export function extractMentionUserIds(body: string): string[] {
  const regex = /@\[[^\]]+]\(user:([^)]+)\)/g;
  const ids = new Set<string>();
  let match: RegExpExecArray | null;
  while ((match = regex.exec(body)) !== null) ids.add(match[1]);
  return [...ids];
}

2.3 Files config: server/chat/chat.files.ts

Stores files inside Replit under uploads/chat.

import multer from "multer";
import path from "path";
import fs from "fs";
import { createId } from "@paralleldrive/cuid2";

const UPLOAD_DIR = path.join(process.cwd(), "uploads", "chat");

if (!fs.existsSync(UPLOAD_DIR)) fs.mkdirSync(UPLOAD_DIR, { recursive: true });

export const chatUpload = multer({
  storage: multer.diskStorage({
    destination: (_req, _file, cb) => cb(null, UPLOAD_DIR),
    filename: (_req, file, cb) => {
      const safeName = file.originalname.replace(/[^\w.\-() ]+/g, "_");
      cb(null, `${createId()}__${safeName}`);
    },
  }),
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB
});

2.4 REST routes: server/chat/chat.routes.ts

Includes:

list conversations w unread + mention count

list messages

upload file (server-side)

mentionable users lookup

save popup preference

import { Router } from "express";
import { z } from "zod";
import { createId } from "@paralleldrive/cuid2";
import { db } from "../db"; // <-- your drizzle db
import {
  users,
  conversations,
  conversationMembers,
  messages,
  messageAttachments,
  notifications,
  userChatSettings,
} from "../../shared/schema";
import { and, eq, desc, gt, isNull, sql } from "drizzle-orm";
import { chatUpload } from "./chat.files";
import { getTokenFromReq, verifyToken, userIdFromDecoded } from "./chat.utils";

export const chatRouter = Router();

// Serve uploads (MUST be mounted in your server too, see index.ts)
chatRouter.get("/health", (_req, res) => res.json({ ok: true }));

async function assertMember(userId: string, conversationId: string) {
  const row = await db
    .select({ id: conversationMembers.id })
    .from(conversationMembers)
    .where(and(eq(conversationMembers.userId, userId), eq(conversationMembers.conversationId, conversationId)))
    .limit(1);
  if (!row.length) throw new Error("Not a member of conversation");
}

function authedUserId(req: any) {
  const token = getTokenFromReq(req);
  if (!token) throw new Error("No token");
  const decoded = verifyToken(token);
  return userIdFromDecoded(decoded);
}

// (A) Conversations list + unread + unread mentions (fast MVP)
chatRouter.get("/conversations", async (req, res) => {
  try {
    const userId = authedUserId(req);

    const memberships = await db
      .select({
        conversationId: conversationMembers.conversationId,
        lastReadAt: conversationMembers.lastReadAt,
      })
      .from(conversationMembers)
      .where(eq(conversationMembers.userId, userId));

    const convIds = memberships.map((m) => m.conversationId);
    if (!convIds.length) return res.json([]);

    const convRows = await db
      .select()
      .from(conversations)
      .where(sql`${conversations.id} = ANY(${convIds})`);

    const results = [];
    for (const conv of convRows) {
      const membership = memberships.find((m) => m.conversationId === conv.id);
      const lastReadAt = membership?.lastReadAt ?? new Date(0);

      const lastMsg = await db
        .select()
        .from(messages)
        .where(and(eq(messages.conversationId, conv.id), isNull(messages.deletedAt)))
        .orderBy(desc(messages.createdAt))
        .limit(1);

      const unreadCount = await db
        .select({ id: messages.id })
        .from(messages)
        .where(and(eq(messages.conversationId, conv.id), gt(messages.createdAt, lastReadAt), isNull(messages.deletedAt)));

      const unreadMentions = await db
        .select({ id: notifications.id })
        .from(notifications)
        .where(
          and(
            eq(notifications.userId, userId),
            eq(notifications.type, "MENTION"),
            eq(notifications.entityId, conv.id),
            isNull(notifications.readAt),
          )
        );

      results.push({
        conversation: conv,
        unreadCount: unreadCount.length,
        unreadMentions: unreadMentions.length,
        lastMessage: lastMsg[0] || null,
      });
    }

    res.json(results);
  } catch (e: any) {
    res.status(400).json({ error: e.message || String(e) });
  }
});

// (B) Messages list (latest 30 MVP)
chatRouter.get("/messages", async (req, res) => {
  try {
    const userId = authedUserId(req);
    const conversationId = String(req.query.conversationId || "");
    await assertMember(userId, conversationId);

    const rows = await db
      .select()
      .from(messages)
      .where(and(eq(messages.conversationId, conversationId), isNull(messages.deletedAt)))
      .orderBy(desc(messages.createdAt))
      .limit(30);

    res.json({ items: rows.reverse(), nextCursor: null });
  } catch (e: any) {
    res.status(400).json({ error: e.message || String(e) });
  }
});

// (C) Upload file to Replit filesystem
chatRouter.post("/upload", chatUpload.single("file"), async (req, res) => {
  try {
    const userId = authedUserId(req);

    const schema = z.object({
      conversationId: z.string(),
    });
    const { conversationId } = schema.parse(req.body);
    await assertMember(userId, conversationId);

    if (!req.file) return res.status(400).json({ error: "No file" });

    const storageKey = req.file.filename; // stored in /uploads/chat
    const url = `/uploads/chat/${storageKey}`;

    res.json({
      storageKey,
      url,
      fileName: req.file.originalname,
      mimeType: req.file.mimetype,
      sizeBytes: req.file.size,
    });
  } catch (e: any) {
    res.status(400).json({ error: e.message || String(e) });
  }
});

// (D) Mentionable users lookup (conversation scoped)
chatRouter.get("/mentions", async (req, res) => {
  try {
    const userId = authedUserId(req);
    const conversationId = String(req.query.conversationId || "");
    const q = String(req.query.q || "").toLowerCase();

    await assertMember(userId, conversationId);

    const rows = await db
      .select({
        id: users.id,
        name: users.name,
        email: users.email,
        avatarUrl: users.avatarUrl,
      })
      .from(conversationMembers)
      .innerJoin(users, eq(users.id, conversationMembers.userId))
      .where(eq(conversationMembers.conversationId, conversationId));

    const filtered = rows
      .filter((u) => (u.name || "").toLowerCase().includes(q) || u.email.toLowerCase().includes(q))
      .slice(0, 10);

    res.json(filtered);
  } catch (e: any) {
    res.status(400).json({ error: e.message || String(e) });
  }
});

// (E) Popup preference (on/off)
chatRouter.post("/settings/popup", async (req, res) => {
  try {
    const userId = authedUserId(req);
    const schema = z.object({ popupEnabled: z.boolean() });
    const { popupEnabled } = schema.parse(req.body);

    // upsert-ish: try update, if 0 rows then insert
    const updated = await db
      .update(userChatSettings)
      .set({ popupEnabled: popupEnabled ? 1 : 0, updatedAt: new Date() })
      .where(eq(userChatSettings.userId, userId))
      .returning({ userId: userChatSettings.userId });

    if (!updated.length) {
      await db.insert(userChatSettings).values({
        userId,
        popupEnabled: popupEnabled ? 1 : 0,
        updatedAt: new Date(),
      });
    }

    res.json({ ok: true });
  } catch (e: any) {
    res.status(400).json({ error: e.message || String(e) });
  }
});

2.5 Socket handlers: server/chat/chat.socket.ts

This includes:

message send (text + attachments)

@mentions persisted + mention notifications

popup trigger event only if recipient has popupEnabled

dashboard notifications always

import { Server } from "socket.io";
import { createId } from "@paralleldrive/cuid2";
import { db } from "../db";
import {
  conversationMembers,
  messages,
  messageAttachments,
  messageReactions,
  messageMentions,
  notifications,
  userChatSettings,
} from "../../shared/schema";
import { and, eq, isNull } from "drizzle-orm";
import { extractMentionUserIds } from "./chat.utils";

async function assertMember(userId: string, conversationId: string) {
  const row = await db
    .select({ id: conversationMembers.id })
    .from(conversationMembers)
    .where(and(eq(conversationMembers.userId, userId), eq(conversationMembers.conversationId, conversationId)))
    .limit(1);
  if (!row.length) throw new Error("Not a member of conversation");
}

async function popupEnabledForUser(userId: string) {
  const rows = await db
    .select({ popupEnabled: userChatSettings.popupEnabled })
    .from(userChatSettings)
    .where(eq(userChatSettings.userId, userId))
    .limit(1);

  // default ON if no row exists
  return rows.length ? rows[0].popupEnabled === 1 : true;
}

export function registerChatSocket(io: Server) {
  io.on("connection", (socket) => {
    const userId: string = socket.data.userId;
    socket.join(`user:${userId}`);

    socket.on("conversation:join", async ({ conversationId }) => {
      await assertMember(userId, conversationId);
      socket.join(`conv:${conversationId}`);
    });

    socket.on("conversation:leave", ({ conversationId }) => {
      socket.leave(`conv:${conversationId}`);
    });

    socket.on("typing:start", async ({ conversationId }) => {
      await assertMember(userId, conversationId);
      socket.to(`conv:${conversationId}`).emit("typing", { conversationId, userId, isTyping: true });
    });

    socket.on("typing:stop", ({ conversationId }) => {
      socket.to(`conv:${conversationId}`).emit("typing", { conversationId, userId, isTyping: false });
    });

    socket.on("read:mark", async ({ conversationId, lastReadMsgId }) => {
      await assertMember(userId, conversationId);

      await db
        .update(conversationMembers)
        .set({ lastReadAt: new Date(), lastReadMsgId: lastReadMsgId || null })
        .where(and(eq(conversationMembers.userId, userId), eq(conversationMembers.conversationId, conversationId)));

      // mark mention notifications as read for this conversation (optional, Teams-like)
      await db
        .update(notifications)
        .set({ readAt: new Date() })
        .where(
          and(
            eq(notifications.userId, userId),
            eq(notifications.type, "MENTION"),
            eq(notifications.entityId, conversationId),
            isNull(notifications.readAt)
          )
        );
    });

    socket.on("message:send", async ({ conversationId, body, attachments = [], replyToId }) => {
      await assertMember(userId, conversationId);

      const messageId = createId();
      const createdAt = new Date();

      await db.insert(messages).values({
        id: messageId,
        conversationId,
        senderId: userId,
        body: body || "",
        bodyFormat: "MARKDOWN",
        createdAt,
        replyToId: replyToId || null,
      });

      // Attachments (files stored on Replit server: url like /uploads/chat/..)
      for (const a of attachments) {
        await db.insert(messageAttachments).values({
          id: createId(),
          messageId,
          fileName: a.fileName,
          mimeType: a.mimeType,
          sizeBytes: a.sizeBytes,
          storageKey: a.storageKey,
          url: a.url,
        });
      }

      // Mentions
      const mentionedUserIds = extractMentionUserIds(body || "");
      for (const mentionedUserId of mentionedUserIds) {
        // ensure mentioned user is in conversation
        await assertMember(mentionedUserId, conversationId);

        await db.insert(messageMentions).values({
          id: createId(),
          messageId,
          mentionedUserId,
        });

        const notifId = createId();
        await db.insert(notifications).values({
          id: notifId,
          userId: mentionedUserId,
          type: "MENTION",
          title: "You were mentioned",
          body: (body || "").slice(0, 140),
          entityId: conversationId,
          messageId,
        });

        // ALWAYS show in dashboard
        io.to(`user:${mentionedUserId}`).emit("notification:new", {
          id: notifId,
          type: "MENTION",
          conversationId,
          messageId,
        });

        // POPUP only if preference enabled
        if (await popupEnabledForUser(mentionedUserId)) {
          io.to(`user:${mentionedUserId}`).emit("chat:popup", {
            conversationId,
            messageId,
            reason: "mention",
          });
        }
      }

      // Notify all other members (MESSAGE notification)
      const members = await db
        .select({ userId: conversationMembers.userId })
        .from(conversationMembers)
        .where(eq(conversationMembers.conversationId, conversationId));

      for (const m of members) {
        if (m.userId === userId) continue;

        const notifId = createId();
        await db.insert(notifications).values({
          id: notifId,
          userId: m.userId,
          type: "MESSAGE",
          title: "New message",
          body: (body || "").slice(0, 140),
          entityId: conversationId,
          messageId,
        });

        io.to(`user:${m.userId}`).emit("notification:new", {
          id: notifId,
          type: "MESSAGE",
          conversationId,
          messageId,
        });

        // Popup for any message (not only mentions) if preference enabled
        if (await popupEnabledForUser(m.userId)) {
          io.to(`user:${m.userId}`).emit("chat:popup", {
            conversationId,
            messageId,
            reason: "message",
          });
        }
      }

      // Emit realtime message into conversation room
      io.to(`conv:${conversationId}`).emit("message:new", {
        id: messageId,
        conversationId,
        senderId: userId,
        body: body || "",
        createdAt: createdAt.toISOString(),
        attachments,
        replyToId: replyToId || null,
      });
    });

    socket.on("reaction:toggle", async ({ messageId, emoji, conversationId }) => {
      await assertMember(userId, conversationId);

      const existing = await db
        .select({ id: messageReactions.id })
        .from(messageReactions)
        .where(and(eq(messageReactions.messageId, messageId), eq(messageReactions.userId, userId), eq(messageReactions.emoji, emoji)))
        .limit(1);

      if (existing.length) {
        await db.delete(messageReactions).where(eq(messageReactions.id, existing[0].id));
      } else {
        await db.insert(messageReactions).values({ id: createId(), messageId, userId, emoji });
      }

      const reactions = await db
        .select()
        .from(messageReactions)
        .where(eq(messageReactions.messageId, messageId));

      io.to(`conv:${conversationId}`).emit("reaction:updated", { messageId, reactions });
    });
  });
}

2.6 Mount module: server/chat/index.ts

This is the glue: mounts routes, serves uploads, sets up socket auth.

import express from "express";
import http from "http";
import cors from "cors";
import { Server } from "socket.io";
import path from "path";

import { chatRouter } from "./chat.routes";
import { registerChatSocket } from "./chat.socket";
import { getTokenFromSocket, verifyToken, userIdFromDecoded } from "./chat.utils";

export function mountChat(app: express.Express) {
  // REST
  app.use("/api/chat", chatRouter);

  // serve uploaded files from Replit filesystem
  app.use("/uploads/chat", express.static(path.join(process.cwd(), "uploads", "chat")));
}

export function createChatIo(server: http.Server) {
  const io = new Server(server, { cors: { origin: "*", methods: ["GET", "POST"] } });

  // Socket auth middleware
  io.use((socket, next) => {
    try {
      const token = getTokenFromSocket(socket);
      if (!token) throw new Error("No token");
      const decoded = verifyToken(token);
      socket.data.userId = userIdFromDecoded(decoded);
      next();
    } catch (e) {
      next(new Error("Unauthorized"));
    }
  });

  registerChatSocket(io);
  return io;
}

2.7 Hook into your existing server entry

Where you create app and server:

import express from "express";
import http from "http";
import { mountChat, createChatIo } from "./chat";

const app = express();
// ... your existing middleware/routes

mountChat(app);

const server = http.createServer(app);
createChatIo(server);

server.listen(process.env.PORT || 3001);

3) Frontend: socket + popup + mentions
3.1 Socket client: src/chat/socket.ts
import { io } from "socket.io-client";

export function createChatSocket(token: string) {
  return io(process.env.CHAT_URL || window.location.origin, {
    auth: { token },
    transports: ["websocket"],
  });
}

3.2 Mention dropdown: src/chat/MentionDropdown.tsx

Minimal, fast, keyboard-friendly.

import React, { useEffect, useState } from "react";

type UserRow = { id: string; name?: string | null; email: string; avatarUrl?: string | null };

export function MentionDropdown({
  open,
  query,
  conversationId,
  token,
  anchorRect,
  onPick,
  onClose,
}: {
  open: boolean;
  query: string;
  conversationId: string;
  token: string;
  anchorRect: DOMRect | null;
  onPick: (u: UserRow) => void;
  onClose: () => void;
}) {
  const [items, setItems] = useState<UserRow[]>([]);
  const [active, setActive] = useState(0);

  useEffect(() => {
    if (!open) return;
    (async () => {
      const r = await fetch(`/api/chat/mentions?conversationId=${conversationId}&q=${encodeURIComponent(query)}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await r.json();
      setItems(Array.isArray(data) ? data : []);
      setActive(0);
    })();
  }, [open, query, conversationId, token]);

  useEffect(() => {
    function onKey(e: KeyboardEvent) {
      if (!open) return;
      if (e.key === "Escape") onClose();
      if (e.key === "ArrowDown") setActive((a) => Math.min(a + 1, items.length - 1));
      if (e.key === "ArrowUp") setActive((a) => Math.max(a - 1, 0));
      if (e.key === "Enter" && items[active]) onPick(items[active]);
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [open, items, active, onPick, onClose]);

  if (!open || !anchorRect) return null;

  return (
    <div
      style={{
        position: "fixed",
        left: anchorRect.left,
        top: anchorRect.bottom + 6,
        width: 280,
        background: "white",
        border: "1px solid #ddd",
        borderRadius: 10,
        boxShadow: "0 8px 20px rgba(0,0,0,0.12)",
        overflow: "hidden",
        zIndex: 9999,
      }}
    >
      {items.map((u, i) => (
        <div
          key={u.id}
          onMouseEnter={() => setActive(i)}
          onMouseDown={(e) => {
            e.preventDefault();
            onPick(u);
          }}
          style={{
            padding: 10,
            cursor: "pointer",
            background: i === active ? "#f2f4f7" : "transparent",
          }}
        >
          <div style={{ fontWeight: 600 }}>{u.name || u.email}</div>
          <div style={{ fontSize: 12, opacity: 0.7 }}>{u.email}</div>
        </div>
      ))}
      {!items.length && <div style={{ padding: 10, opacity: 0.7 }}>No matches</div>}
    </div>
  );
}

3.3 Chat panel (with popup handling): src/chat/ChatPanel.tsx

This:

loads conversations

loads messages

sends messages

uploads files to Replit server filesystem

@ detection + dropdown + insertion token

listens for chat:popup and opens popup panel if enabled

import React, { useEffect, useMemo, useRef, useState } from "react";
import { createChatSocket } from "./socket";
import { MentionDropdown } from "./MentionDropdown";

function getMentionQuery(text: string, cursor: number) {
  const left = text.slice(0, cursor);
  const match = left.match(/(^|\s)@([a-zA-Z0-9_]*)$/);
  if (!match) return null;
  return { query: match[2], start: cursor - match[2].length - 1, end: cursor };
}

function insertMention(text: string, start: number, end: number, user: { id: string; name?: string | null; email: string }) {
  const display = user.name || user.email;
  const token = `@[${display}](user:${user.id})`;
  return text.slice(0, start) + token + " " + text.slice(end);
}

export function ChatPanel({ token, initialOpen = false }: { token: string; initialOpen?: boolean }) {
  const socket = useMemo(() => createChatSocket(token), [token]);

  const [open, setOpen] = useState(initialOpen);
  const [convos, setConvos] = useState<any[]>([]);
  const [activeId, setActiveId] = useState<string | null>(null);
  const [messages, setMessages] = useState<any[]>([]);
  const [draft, setDraft] = useState("");
  const [attachments, setAttachments] = useState<any[]>([]);

  const inputRef = useRef<HTMLInputElement | null>(null);
  const [mentionOpen, setMentionOpen] = useState(false);
  const [mentionQuery, setMentionQuery] = useState("");
  const [mentionRange, setMentionRange] = useState<{ start: number; end: number } | null>(null);
  const [anchorRect, setAnchorRect] = useState<DOMRect | null>(null);

  async function loadConvos() {
    const r = await fetch("/api/chat/conversations", {
      headers: { Authorization: `Bearer ${token}` },
    });
    const data = await r.json();
    setConvos(Array.isArray(data) ? data : []);
    if (!activeId && Array.isArray(data) && data[0]?.conversation?.id) setActiveId(data[0].conversation.id);
  }

  async function loadMessages(conversationId: string) {
    const r = await fetch(`/api/chat/messages?conversationId=${conversationId}`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    const data = await r.json();
    setMessages(data.items || []);
    socket.emit("read:mark", { conversationId, lastReadMsgId: data.items?.at?.(-1)?.id });
  }

  useEffect(() => {
    loadConvos();

    socket.on("notification:new", () => {
      loadConvos(); // simple + accurate MVP
    });

    socket.on("chat:popup", ({ conversationId }: any) => {
      // POPUP behavior: open chat and switch conversation
      setOpen(true);
      setActiveId(conversationId);
    });

    return () => {
      socket.disconnect();
    };
    // eslint-disable-next-line
  }, []);

  useEffect(() => {
    if (!activeId) return;

    socket.emit("conversation:join", { conversationId: activeId });
    loadMessages(activeId);

    const onNew = (msg: any) => {
      if (msg.conversationId !== activeId) return;
      setMessages((m) => [...m, msg]);
    };

    socket.on("message:new", onNew);

    return () => {
      socket.emit("conversation:leave", { conversationId: activeId });
      socket.off("message:new", onNew);
    };
  }, [activeId]);

  async function uploadFile(file: File) {
    if (!activeId) return;
    const fd = new FormData();
    fd.append("file", file);
    fd.append("conversationId", activeId);

    const r = await fetch("/api/chat/upload", {
      method: "POST",
      headers: { Authorization: `Bearer ${token}` },
      body: fd,
    });
    const data = await r.json();
    if (data?.url) setAttachments((a) => [...a, data]);
  }

  function send() {
    if (!activeId) return;
    const body = draft.trim();
    if (!body && !attachments.length) return;

    socket.emit("message:send", {
      conversationId: activeId,
      body,
      attachments,
    });

    setDraft("");
    setAttachments([]);
    setMentionOpen(false);
  }

  function onDraftChange(v: string) {
    setDraft(v);

    const el = inputRef.current;
    const cursor = el?.selectionStart ?? v.length;
    const mq = getMentionQuery(v, cursor);

    if (mq && activeId) {
      setMentionOpen(true);
      setMentionQuery(mq.query);
      setMentionRange({ start: mq.start, end: mq.end });

      // anchor dropdown under input (simple MVP)
      setAnchorRect(el!.getBoundingClientRect());
    } else {
      setMentionOpen(false);
      setMentionRange(null);
    }
  }

  function pickMention(u: any) {
    if (!mentionRange) return;
    const next = insertMention(draft, mentionRange.start, mentionRange.end, u);
    setDraft(next);
    setMentionOpen(false);

    requestAnimationFrame(() => {
      inputRef.current?.focus();
    });
  }

  // UI
  if (!open) {
    return (
      <button onClick={() => setOpen(true)} style={{ padding: "10px 12px" }}>
        Open Chat
      </button>
    );
  }

  return (
    <div style={{
      position: "fixed",
      right: 16,
      bottom: 16,
      width: 420,
      height: 560,
      background: "white",
      border: "1px solid #ddd",
      borderRadius: 14,
      boxShadow: "0 12px 30px rgba(0,0,0,0.15)",
      display: "flex",
      overflow: "hidden",
      zIndex: 9998
    }}>
      {/* Left sidebar */}
      <div style={{ width: 160s=160, borderRight: "1px solid #eee", overflow: "auto" }}>
        <div style={{ padding: 10, fontWeight: 700, display: "flex", justifyContent: "space-between" }}>
          <span>Chat</span>
          <button onClick={() => setOpen(false)}>‚úï</button>
        </div>

        {convos.map((c) => (
          <div
            key={c.conversation.id}
            onClick={() => setActiveId(c.conversation.id)}
            style={{
              padding: 10,
              cursor: "pointer",
              background: activeId === c.conversation.id ? "#f5f5f5" : "transparent",
              borderBottom: "1px solid #f0f0f0",
            }}
          >
            <div style={{ display: "flex", justifyContent: "space-between", gap: 8 }}>
              <div style={{ fontWeight: 600, fontSize: 13 }}>
                {c.conversation.name || c.conversation.type}
              </div>
              <div style={{ display: "flex", gap: 6 }}>
                {c.unreadMentions > 0 && (
                  <span style={{ fontSize: 12, padding: "1px 7px", borderRadius: 999, background: "#ffe6e6" }}>
                    @
                  </span>
                )}
                {c.unreadCount > 0 && (
                  <span style={{ fontSize: 12, padding: "1px 7px", borderRadius: 999, background: "#ddd" }}>
                    {c.unreadCount}
                  </span>
                )}
              </div>
            </div>
            <div style={{ fontSize: 12, opacity: 0.7 }}>
              {c.lastMessage?.body?.slice(0, 40) || ""}
            </div>
          </div>
        ))}
      </div>

      {/* Right panel */}
      <div style={{ flex: 1, display: "flex", flexDirection: "column" }}>
        <div style={{ padding: 10, borderBottom: "1px solid #eee", fontWeight: 700 }}>
          {activeId ? "Conversation" : "Select a chat"}
        </div>

        <div style={{ flex: 1, overflow: "auto", padding: 10 }}>
          {messages.map((m) => (
            <div key={m.id} style={{ marginBottom: 10 }}>
              <div style={{ fontSize: 12, opacity: 0.7 }}>
                {m.senderId} ‚Ä¢ {new Date(m.createdAt).toLocaleString()}
              </div>
              <div style={{ whiteSpace: "pre-wrap" }}>{m.body}</div>
              {!!m.attachments?.length && (
                <div style={{ marginTop: 6 }}>
                  {m.attachments.map((a: any) => (
                    <a key={a.storageKey} href={a.url} target="_blank" rel="noreferrer">
                      üìé {a.fileName}
                    </a>
                  ))}
                </div>
              )}
            </div>
          ))}
        </div>

        {/* attachments preview */}
        {attachments.length > 0 && (
          <div style={{ padding: "6px 10px", borderTop: "1px solid #eee", fontSize: 12 }}>
            {attachments.map((a: any) => (
              <div key={a.storageKey}>üìé {a.fileName}</div>
            ))}
          </div>
        )}

        {/* composer */}
        <div style={{ borderTop: "1px solid #eee", padding: 10, display: "flex", gap: 8 }}>
          <input
            ref={inputRef}
            value={draft}
            onChange={(e) => onDraftChange(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                send();
              }
            }}
            placeholder="Type a message‚Ä¶ (use @ to mention)"
            style={{ flex: 1, padding: 10, border: "1px solid #ddd", borderRadius: 10 }}
          />
          <input
            type="file"
            onChange={(e) => {
              const f = e.target.files?.[0];
              if (f) uploadFile(f);
              e.currentTarget.value = "";
            }}
          />
          <button onClick={send} style={{ padding: "10px 12px" }}>Send</button>
        </div>

        <MentionDropdown
          open={mentionOpen}
          query={mentionQuery}
          conversationId={activeId || ""}
          token={token}
          anchorRect={anchorRect}
          onPick={pickMention}
          onClose={() => setMentionOpen(false)}
        />
      </div>
    </div>
  );
}


Note: this is an MVP UI. It‚Äôs already functional and matches your requirements: server-stored files, mentions, popup option, dashboard integration hooks.

4) Dashboard widget (must show unread + open popup)

Create src/dashboard/ChatWidget.tsx:

import React, { useEffect, useMemo, useState } from "react";
import { createChatSocket } from "../chat/socket";
import { ChatPanel } from "../chat/ChatPanel";

export function ChatWidget({ token }: { token: string }) {
  const socket = useMemo(() => createChatSocket(token), [token]);
  const [summary, setSummary] = useState({ unread: 0, mentions: 0 });
  const [openChat, setOpenChat] = useState(false);

  async function refresh() {
    const r = await fetch("/api/chat/conversations", {
      headers: { Authorization: `Bearer ${token}` },
    });
    const data = await r.json();
    const unread = (data || []).reduce((s: number, c: any) => s + (c.unreadCount || 0), 0);
    const mentions = (data || []).reduce((s: number, c: any) => s + (c.unreadMentions || 0), 0);
    setSummary({ unread, mentions });
  }

  useEffect(() => {
    refresh();
    socket.on("notification:new", () => refresh());
    socket.on("chat:popup", () => setOpenChat(true));
    return () => socket.disconnect();
    // eslint-disable-next-line
  }, []);

  return (
    <div style={{ border: "1px solid #ddd", borderRadius: 12, padding: 12 }}>
      <div style={{ fontWeight: 700, display: "flex", justifyContent: "space-between" }}>
        <span>Chat</span>
        <button onClick={() => setOpenChat(true)}>Open</button>
      </div>
      <div style={{ marginTop: 8, display: "flex", gap: 10 }}>
        <div>Unread: <b>{summary.unread}</b></div>
        <div>Mentions: <b>{summary.mentions}</b></div>
      </div>

      {openChat && <ChatPanel token={token} initialOpen={true} />}
    </div>
  );
}


Drop <ChatWidget token={token} /> onto your main dashboard.

5) Popup preference UI toggle (required)

Add a toggle somewhere in user settings (or dashboard):

async function setPopup(token: string, enabled: boolean) {
  await fetch("/api/chat/settings/popup", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify({ popupEnabled: enabled }),
  });
}


Behavior:

If popup enabled: any incoming message triggers chat:popup event ‚Üí opens chat panel.

If disabled: still shows unread + dashboard widget, but no popup.

6) Replit operational notes (important)
6.1 Files are stored on Replit server filesystem

Stored in: uploads/chat/

Served from: /uploads/chat/<filename>

This matches your requirement: ‚Äúsave in Replit itself, store all files server side‚Äù.

6.2 Persistence warning (Replit)

Replit deployments can reset filesystem depending on how you deploy. If you want guaranteed persistence, you‚Äôll eventually want an attached volume or object storage. But per your instruction, this version is 100% server-side in Replit.

7) What Replit must implement (checklist)
Backend

 Add schema tables in shared/schema.ts

 Run npm run db:push

 Add chat module files

 Mount:

/api/chat/* routes

/uploads/chat/* static serving

 Confirm Socket.IO server uses your existing JWT auth

Frontend

 Add socket client

 Add ChatPanel + ChatWidget

 Put ChatWidget on dashboard

 Ensure token is available client-side (same token used for API auth)

8) Copy/paste ‚Äúdone criteria‚Äù

When finished, this must work:

User A sends message to User B in a conversation
‚úÖ B sees unread badge on dashboard widget
‚úÖ If popup enabled, chat panel opens automatically

User types @
‚úÖ Dropdown lists conversation members
‚úÖ Clicking inserts @[Name](user:ID) token

When message includes mention
‚úÖ Mentioned user gets MENTION notification + mention badge @
‚úÖ Popup triggers (if enabled)

File attach
‚úÖ File uploads to uploads/chat/
‚úÖ Message includes attachment link that opens file